/**
 **********************************************************************
 * @file           : main.c
 * @author         : You
 * @brief          : RGB PWM on PB15 (TIM1_CH3N), PB14 (TIM1_CH2N), PB1 (TIM3_CH4)
 **********************************************************************
 */
/**
 ********************************************************************
 * @file           : main.c
 * @author         : You
 * @brief          : RGB PWM on PB15 (TIM1_CH3N), PB14 (TIM1_CH2N), PB1 (TIM3_CH4)
 ********************************************************************
 */
#define STM32F411xE
#include <stdint.h>
#include "stm32f4xx.h"
volatile uint32_t THRESHOLD = 1333333u;

#define MAX_BRIGHT 1000  // 0..1000 ~= 0..100% duty

static inline uint16_t clamp_u16(uint16_t v, uint16_t hi) {
    return (v > hi) ? hi : v;
}

// -------------------- USART --------------------
void USART2_Init(void) {
    // Enable clocks for A, B, C GPIO and USART2
    RCC->AHB1ENR |= RCC_AHB1ENR_GPIOAEN + RCC_AHB1ENR_GPIOBEN + RCC_AHB1ENR_GPIOCEN;
    RCC->APB1ENR |= RCC_APB1ENR_USART2EN;
    // PA2 = TX, PA3 = RX (AF7)
    GPIOA->MODER &= ~(GPIO_MODER_MODER2 | GPIO_MODER_MODER3);
    GPIOA->MODER |= (0b10 << GPIO_MODER_MODER2_Pos) | (0b10 << GPIO_MODER_MODER3_Pos);
    GPIOA->AFR[0] &= ~(GPIO_AFRL_AFSEL2 | GPIO_AFRL_AFSEL3);
    GPIOA->AFR[0] |= (0b0111 << GPIO_AFRL_AFSEL2_Pos) | (0b0111 << GPIO_AFRL_AFSEL3_Pos);
    USART2->CR1 = 0;
    USART2->CR1 |= USART_CR1_UE; // enable USART
    USART2->CR1 &= ~USART_CR1_M; // 8-bit data
    USART2->CR2 &= ~USART_CR2_STOP; // 1 stop bit
    USART2->BRR = 139; // Baud = 115200 @16MHz
    USART2->CR1 |= USART_CR1_TE | USART_CR1_RE; // enable Tx and Rx
}

char USART2_ReadChar(void) {
    while (!(USART2->SR & USART_SR_RXNE));
    return (char)(USART2->DR & 0xFF);
}

void GPIO_Init(void) {
    // 7-segment display outputs
    GPIOA->MODER &= ~(GPIO_MODER_MODER8 | GPIO_MODER_MODER9); // PA8, PA9 for display
    GPIOA->MODER |= (0b01 << GPIO_MODER_MODER8_Pos) | (0b01 << GPIO_MODER_MODER9_Pos);
    GPIOB->MODER &= ~(GPIO_MODER_MODER10); // PB10 for display
    GPIOB->MODER |= (0b01 << GPIO_MODER_MODER10_Pos);
    GPIOC->MODER &= ~(GPIO_MODER_MODER7); // PC7 for display
    GPIOC->MODER |= (0b01 << GPIO_MODER_MODER7_Pos);

    // Button inputs (with internal pull-ups)
    GPIOA->MODER &= ~(GPIO_MODER_MODER10); // PA10 - car count increase
    GPIOA->PUPDR |= (0b01 << GPIO_PUPDR_PUPD10_Pos); // pull-up

    GPIOB->MODER &= ~(GPIO_MODER_MODER3 | GPIO_MODER_MODER4 | GPIO_MODER_MODER5); // PB3, PB4, PB5
    GPIOB->PUPDR |= (0b01 << GPIO_PUPDR_PUPD3_Pos) | (0b01 << GPIO_PUPDR_PUPD5_Pos); // pull-up for PB3, PB5
    // PB4 emergency mode - no pull-up (external circuit handles)

    // LED outputs - Traffic Lights
    GPIOA->MODER &= ~(GPIO_MODER_MODER5 | GPIO_MODER_MODER6 | GPIO_MODER_MODER7); // PA5 blue, PA6 red, PA7 yellow
    GPIOA->MODER |= (0b01 << GPIO_MODER_MODER5_Pos) | (0b01 << GPIO_MODER_MODER6_Pos) | (0b01 << GPIO_MODER_MODER7_Pos);

    GPIOB->MODER &= ~(GPIO_MODER_MODER6); // PB6 green
    GPIOB->MODER |= (0b01 << GPIO_MODER_MODER6_Pos);
}

void RGB_PWM_Init(void) {
    // Enable GPIOB + timers TIM1 (APB2) and TIM3 (APB1)
    RCC->AHB1ENR |= RCC_AHB1ENR_GPIOBEN;
    RCC->APB2ENR |= RCC_APB2ENR_TIM1EN;
    RCC->APB1ENR |= RCC_APB1ENR_TIM3EN;

    // ===== Configure PB15 (AF1, TIM1_CH3N), PB14 (AF1, TIM1_CH2N), PB1 (AF2, TIM3_CH4) =====
    // Set to AF mode
    GPIOB->MODER &= ~((3U<<(15*2)) | (3U<<(14*2)) | (3U<<(1*2)));
    GPIOB->MODER |=  (2U<<(15*2)) | (2U<<(14*2)) | (2U<<(1*2));

    // Speed and no-pull
    GPIOB->OSPEEDR |= (2U<<(15*2)) | (2U<<(14*2)) | (2U<<(1*2));
    GPIOB->PUPDR   &= ~((3U<<(15*2)) | (3U<<(14*2)) | (3U<<(1*2)));

    // AFR: PB14/PB15 are in AFR[1]; PB1 is in AFR[0]
    // PB14 -> AF1, PB15 -> AF1
    GPIOB->AFR[1] &= ~((0xFU<<((14-8)*4)) | (0xFU<<((15-8)*4)));
    GPIOB->AFR[1] |=  ((0x1U<<((14-8)*4)) | (0x1U<<((15-8)*4)));
    // PB1 -> AF2 (TIM3)
    GPIOB->AFR[0] &= ~(0xFU<<(1*4));
    GPIOB->AFR[0] |=  (0x2U<<(1*4));

    // ===== TIM1 setup (for PB14 CH2N and PB15 CH3N) =====
    // Aim ~1 kHz PWM with ~1 MHz counter (common clocking: TIM1 clock ~84 MHz)
    TIM1->CR1 = 0;
    TIM1->PSC = 84 - 1;               // 84 MHz / 84 = 1 MHz
    TIM1->ARR = MAX_BRIGHT - 1;       // -> 1 kHz

    // CH2 PWM1 + preload (CCMR1 OC2)
    TIM1->CCMR1 &= ~(7U<<12);
    TIM1->CCMR1 |=  (6U<<12);         // OC2M = 110 (PWM1)
    TIM1->CCMR1 |=  TIM_CCMR1_OC2PE;  // preload enable

    // CH3 PWM1 + preload (CCMR2 OC3)
    TIM1->CCMR2 &= ~(7U<<4);
    TIM1->CCMR2 |=  (6U<<4);          // OC3M = 110 (PWM1)
    TIM1->CCMR2 |=  TIM_CCMR2_OC3PE;  // preload enable

    // Start with duty = 0
    TIM1->CCR2 = 0; // G
    TIM1->CCR3 = 0; // R

    // Enable complementary outputs for CH2N and CH3N
    TIM1->CCER = 0;
    TIM1->CCER |= TIM_CCER_CC2NE | TIM_CCER_CC3NE;
    // Polarity left default; flip CCxNP/CCxP if your hardware is active-low

    // Main output enable (advanced timer)
    TIM1->BDTR = TIM_BDTR_MOE;

    // Latch + enable
    TIM1->CR1 |= TIM_CR1_ARPE;
    TIM1->EGR  = TIM_EGR_UG;
    TIM1->CR1 |= TIM_CR1_CEN;

    // ===== TIM3 setup (for PB1 CH4) =====
    // Common configs often make TIM3 clock effectively 84 MHz (APB1 x2 for timers)
    TIM3->CR1 = 0;
    TIM3->PSC = 84 - 1;               // ~1 MHz counter
    TIM3->ARR = MAX_BRIGHT - 1;       // -> 1 kHz

    // CH4 PWM1 + preload (CCMR2 OC4)
    TIM3->CCMR2 &= ~(7U<<12);
    TIM3->CCMR2 |=  (6U<<12);         // OC4M = 110 (PWM1)
    TIM3->CCMR2 |=  TIM_CCMR2_OC4PE;  // preload enable

    // Start with duty = 0
    TIM3->CCR4 = 0; // B

    // Enable CH4 output
    TIM3->CCER = 0;
    TIM3->CCER |= TIM_CCER_CC4E;

    // Latch + enable
    TIM3->CR1 |= TIM_CR1_ARPE;
    TIM3->EGR  = TIM_EGR_UG;
    TIM3->CR1 |= TIM_CR1_CEN;
}

static inline void Set_RGB(uint16_t R, uint16_t G, uint16_t B) {
    uint16_t top1 = TIM1->ARR; // same as TIM3->ARR (both set to MAX_BRIGHT-1)
    uint16_t top3 = TIM3->ARR;

    TIM1->CCR3 = clamp_u16(R, top1);   // R on PB15 (CH3N)
    TIM1->CCR2 = clamp_u16(G, top1);   // G on PB14 (CH2N)
    TIM3->CCR4 = clamp_u16(B, top3);   // B on PB1  (CH4)
}

uint32_t ReadPotentiometer(void) {
    ADC1->CR2 |= ADC_CR2_SWSTART;  // สั่งเริ่มการแปลง ADC

    // รอจนกว่าการแปลงจะเสร็จ
    while(!(ADC1->SR & ADC_SR_EOC));

    return ADC1->DR;  // อ่านค่า ADC
}

void UpdateThresholdFromADC(void) {
    uint32_t adc_value = ReadPotentiometer();
    // ช่วง 1–5 วินาทีแบบชัดเจน
    const uint32_t MIN_US = 1000000u;
    const uint32_t MAX_US = 5000000u;
    THRESHOLD = MIN_US + (uint32_t)(((uint64_t)adc_value * (MAX_US - MIN_US)) / 4095u);
}

void ADC1_POT_Init(void) {
    // เปิด clock สำหรับ GPIOA และ ADC1
    RCC->AHB1ENR |= RCC_AHB1ENR_GPIOAEN;
    RCC->APB2ENR |= RCC_APB2ENR_ADC1EN;

    // ตั้งค่า PA4 เป็น Analog mode
    GPIOA->MODER &= ~GPIO_MODER_MODER4;
    GPIOA->MODER |= (0b11 << GPIO_MODER_MODER4_Pos);  // Analog mode

    // ตั้งค่า ADC1
    ADC1->CR2 |= ADC_CR2_ADON;                // เปิด ADC
    ADC1->SMPR2 &= ~ADC_SMPR2_SMP4;           // Clear sampling time
    ADC1->SMPR2 |= (0b011 << ADC_SMPR2_SMP4_Pos); // 56 cycles sampling time
    ADC1->SQR1 &= ~ADC_SQR1_L;                // 1 conversion
    ADC1->SQR3 &= ~ADC_SQR3_SQ1;              // Clear sequence
    ADC1->SQR3 |= (4 << ADC_SQR3_SQ1_Pos);    // Channel 4 (PA4)
}

//static inline uint16_t clamp_u16(uint16_t v, uint16_t hi) {
//    return (v > hi) ? hi : v;
//}

void Display_Number(char rx) {
    // เคลียร์ก่อน (ปิดทุกขา)
    GPIOC->ODR &= ~(1 << 7); // PC7
    GPIOA->ODR &= ~(1 << 8); // PA8
    GPIOA->ODR &= ~(1 << 9); // PA9
    GPIOB->ODR &= ~(1 << 10); // PB10

    switch (rx) {
        case '0': break; // 0000 -> ทุกตัวดับ
        case '1': GPIOC->ODR |= (1 << 7); break; // 0001
        case '2': GPIOA->ODR |= (1 << 8); break; // 0010
        case '3': GPIOA->ODR |= (1 << 8); GPIOC->ODR |= (1 << 7); break; // 0011
        case '4': GPIOB->ODR |= (1 << 10); break; // 0100
        case '5': GPIOB->ODR |= (1 << 10); GPIOC->ODR |= (1 << 7); break; // 0101
        case '6': GPIOA->ODR |= (1 << 8); GPIOB->ODR |= (1 << 10); break; // 0110
        case '7': GPIOA->ODR |= (1 << 8); GPIOB->ODR |= (1 << 10); GPIOC->ODR |= (1 << 7); break; // 0111
        case '8': GPIOA->ODR |= (1 << 9); break; // 1000
        case '9': GPIOA->ODR |= (1 << 9); GPIOC->ODR |= (1 << 7); break; // 1001
        default: break;
    }
}
// -------------------- Traffic Light Functions --------------------
void turn_off_all_lights_lane1(void){  //ใช้กับไฟเลน 1
    GPIOA->ODR &= ~(1 << 6); // red off
    GPIOA->ODR &= ~(1 << 7); // yellow off
    GPIOB->ODR &= ~(1 << 6); // green off
}

void set_green_light_lane1(void) {
	turn_off_all_lights_lane1();
    GPIOB->ODR |= (1 << 6); // PB6 green - Lane 1 green

}

void set_red_light_lane1(void) {
	turn_off_all_lights_lane1();
    GPIOA->ODR |= (1 << 6); // PA6 red - Lane 1 red
}

void set_yellow_light_lane1(void) {
	turn_off_all_lights_lane1();
    GPIOA->ODR |= (1 << 7); // PA7 yellow - Lane 1 yellow
}


//--- set traffic light lane 2 ยังไม่ทำ ------//

static inline void LED_Red(void)    { Set_RGB(MAX_BRIGHT, 0,           0); }
static inline void LED_Green(void)  { Set_RGB(0,           MAX_BRIGHT, 0); }
static inline void LED_Blue(void)   { Set_RGB(0,           0,           MAX_BRIGHT); }
static inline void LED_Yellow(void) { Set_RGB(MAX_BRIGHT,  MAX_BRIGHT/2,  0); }


//------------------------------------------//

void ADC_IRQHandler(void) {
    if((ADC1->SR & ADC_SR_EOC) != 0) {
        uint32_t adc_value = ADC1->DR;  // Read ADC value (also clears EOC flag)

        if (adc_value <= 2048) {
            GPIOA->ODR |= GPIO_ODR_ODR_5;   // Turn ON LED (PA5)
        } else {
            GPIOA->ODR &= ~GPIO_ODR_ODR_5;  // Turn OFF LED (PA5)
        }
    }
}

// -------------------- Countdown Display Function --------------------


uint32_t countdown_display_lane1(uint32_t seconds, uint32_t car_count) {

    if (car_count == 0) {
        seconds = seconds - 1;
    }

   if (seconds> 9){
	   seconds = 9;
   }

    // ใช้ signed int เพื่อให้วนไปถึง 0 ได้
    for (int32_t remaining = seconds; remaining >= 0; remaining--) {
    	UpdateThresholdFromADC();
        Display_Number('0' + remaining);

        if (car_count > 0) {
            // เปิดไฟตามสถานะ
            if (remaining > 2) {
                set_green_light_lane1();   // ไฟเลน 1 เขียว
                LED_Red();                 // RGB เป็นสีแดง (ตรวจสอบว่าต้องการจริงหรือไม่)
            }
            else if (remaining == 2) {
                set_yellow_light_lane1();
            }
            else if (remaining == 1) {
                set_red_light_lane1();
            }
        }

        else {
            	LED_Red();
                set_red_light_lane1();
        }
        // ดีเลย์ประมาณ 1 วินาที
        for (volatile uint32_t i = 0; i < THRESHOLD; i++) {
            // busy-wait 1 วินาที
        }

    }
    if (car_count>0){
    	if (car_count<=9){
    		return car_count-(seconds-2);
    	}
    	else{
    	return car_count-7;
    	}
    }else{
    	return car_count;
    }
}



uint32_t countdown_display_lane2(uint32_t seconds, uint32_t car_count) {

    if (car_count == 0) {
        seconds = seconds - 1;
    }

    if (seconds> 9){
 	   seconds = 9;
    }

    // ใช้ signed int เพื่อให้วนไปถึง 0 ได้
    for (int32_t remaining = seconds; remaining >= 0; remaining--) {
    	UpdateThresholdFromADC();

        Display_Number('0' + remaining);

        if (car_count > 0) {
            // เปิดไฟตามสถานะ
            if (remaining > 2) {
            	LED_Green();
            }
            else if (remaining == 2) {
            	LED_Yellow();
            }
            else if (remaining == 1) {
            	LED_Red();
            }
        }

        else {
        	LED_Red();
        }
        // ดีเลย์ประมาณ 1 วินาที
        for (volatile uint32_t i = 0; i < THRESHOLD; i++) {
            // busy-wait 1 วินาที
        }

    }
    if (car_count>0){
    	if (car_count<=9){
    		return car_count-(seconds-2);
    	}
    	else{
    	return car_count-7;
    	}
    }else{
    	return car_count;
    }
}


uint32_t time_check(uint32_t car_count) {
    uint32_t t;   // ประกาศตัวแปรก่อนใช้

    if (car_count == 0) {
        t = 1;
    } else {
        if (car_count < 10) {
            t = car_count;
        } else {
            t = 9;
        }
    }

    return t;   // ใส่ ; ปิดท้าย
}


uint32_t wait_for_release_button(uint32_t car_count) {
    uint8_t prev_PA10 = 1;
    uint8_t prev_PB3  = 1;

    while ((GPIOB->IDR & (1 << 5)) != 0) {   // รอจนกด PB5
        uint8_t curr_PA10 = (GPIOA->IDR & (1 << 10)) ? 1 : 0;
        uint8_t curr_PB3  = (GPIOB->IDR & (1 << 3)) ? 1 : 0;
        UpdateThresholdFromADC();

        // PA10: เพิ่มรถ (edge: 1 -> 0)
        if (prev_PA10 == 1 && curr_PA10 == 0) {
            car_count++;
        }
        prev_PA10 = curr_PA10;

        // PB3: ลดรถ (edge: 1 -> 0)
        if (prev_PB3 == 1 && curr_PB3 == 0) {
            if (car_count > 0) car_count--;
        }
        prev_PB3 = curr_PB3;
    }
    return car_count;
}

// -------------------- Main Program --------------------
int main(void) {
    USART2_Init(); // cool terms
    GPIO_Init();   // gpios
    RGB_PWM_Init();
    ADC1_POT_Init();

    // Traffic light variables
    volatile uint32_t car_count[2] = {0,0};
    uint32_t n = 0;
    uint32_t t = 1; // default green time

    turn_off_all_lights_lane1(); // start with all lights off

    while (1) {
        //เลน 1
    	if (n%2 == 0){

    	GPIOA->ODR |= (1<<5);

        // GREEN PHASE - Lane 1 green (no cars waiting, show car count)
        turn_off_all_lights_lane1();
        car_count[n%2] = countdown_display_lane1(t+2, car_count[n%2]);

        // Wait for release button or timeout
        car_count[(n+1)%2] = wait_for_release_button(car_count[(n+1)%2]);
        t=time_check(car_count[(n+1)%2]);
        n++;
        //แดงเลน 1 ค้างไว้
    }
    //เลน 2
    else{
        GPIOA->ODR &= ~(1 << 5); // blue off

        //ใช้ BCD ให้นับไฟทั้งเขียว+เหลือง+แดง ของเลน 2 ก็เหมือนเวลาไฟแดงเลน 1 ระหว่างนั้นไฟแดงเลน 1 ติดค้างไว้
    	car_count[n%2] = countdown_display_lane2(t+2, car_count[n%2]);
    	//เพิ่มจำนวนรถของอีกเลน
    	car_count[(n+1)%2] = wait_for_release_button(car_count[(n+1)%2]);
        t=time_check(car_count[(n+1)%2]);
    	n++;
        //ไฟแดงของเลน 2 ติดค้างไว้
     }
   }
}
